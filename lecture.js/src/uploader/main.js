/**
 * @module uploader
 * @desc connects to the YouTube Data API and uploads videos
 *
 * @example
 * const _ = {};
 * _.uploader = require('/uploader/main.js');
 */

'use strict';

/*
 * =======
 * MODULES
 * =======
 */

const _ = {};
_.fs    = require('fs');
_.path  = require('path');
_.os    = require('os');
_.https = require('https');

// utility scripts
_.basic     = require('../.global/basic-utilities.js');
_.type      = require('../.global/type-tests.js');
_.logger    = require('../.global/logger.js');
_.timestamp = require('../.global/timestamp.js');

// npm modules
_.googleapis = require('googleapis');
_.open = require('open');



/*
 * =========
 * CONSTANTS
 * =========
 */

const EOL = _.os.EOL;

const OAUTH2 = _.googleapis.google.auth.OAuth2;
const TOKEN_PATH = _.path.join(__dirname, '.tokens', 'yt-upload-token.json');
        
// if the scope needs to be changed, delete old tokens generated by the script
const SCOPES = [
    'https://www.googleapis.com/auth/youtube',
    'https://www.googleapis.com/auth/youtube.upload'
];



/*
 * ===========
 * DEFINITIONS
 * ===========
 */

let OAUTH2_CLIENT = null;



/*
 * =================
 * PRIVATE FUNCTIONS
 * =================
 */

/**
 * initializes an OAuth2 client
 *
 * @async
 * @function
 * @alias module:uploader
 * @category private
 *
 * @returns {Promise.<boolean>} true on success
 */
const initClient = async(credentials_file_path) => {
    
    // if already authorized, return
    if (OAUTH2_CLIENT) {
        return true;
    }
    
    // check if the credentials file exists
    if (!_.basic.isFile(credentials_file_path, '.json')) {
        _.logger.error(`Expected path to an existing JSON credentials file, but got ${_.type.of(credentials_file_path)} "${credentials_file_path}"`);
        return;
    }
    
    _.logger.message(`Initializing an OAuth2 client for the connection to the YouTube API...`);
    
    // reading credentials file
    try {
        let credentials = JSON.parse(_.fs.readFileSync(credentials_file_path));

        // initialize the client
        OAUTH2_CLIENT = new OAUTH2(
            credentials.installed.client_id,
            credentials.installed.client_secret, 
            credentials.installed.redirect_uris[0]
        );
    }
    catch (err) {
        _.logger.error(`Failed applying credentials to the OAuth2 client, because: ${err}`);
        OAUTH2_CLIENT = null;
        return false;
    }
    
    // generate a new token file, if it does not exist yet
    if (!_.fs.existsSync(TOKEN_PATH)) {
        let success = await generateNewTokenFile();
        if (!success) {
            _.logger.error(`Failed generating a new access token file`);
            // reset the client
            OAUTH2_CLIENT = null;
            return false;
        }
    }
    
    // read token file and apply it to client
    let token = _.fs.readFileSync(TOKEN_PATH);
    OAUTH2_CLIENT.credentials = JSON.parse(token);
    
    return true;
};

/**
 * generates a new token file after prompting for user authorization
 *
 * @async
 * @function
 * @alias module:uploader
 * @category private
 *
 * @returns {Promise.<boolean>} true on success
 */
const generateNewTokenFile = async() => {
    
    // if client is not yet initialized, return
    if (!OAUTH2_CLIENT) {
        _.logger.error(`OAuth2 client is not yet initialized`);
        return false;
    }
    
    var authentification_url = OAUTH2_CLIENT.generateAuthUrl({
        access_type : 'offline',
        scope       : SCOPES
    });
    
    // print the authentification URL for the user
    _.logger.info(`To access the YouTube API, authorize this app. Visit this url and log-in:`);
    console.log(EOL + authentification_url + EOL);
    
    // also open the URL directly in the user's default browser
    await _.open(authentification_url);
    
    // wait for the user to enter the authentification code
    let code = await _.logger.question(`Enter the authorization code from that page here:`);
    
    return await new Promise(resolve => {
        
        OAUTH2_CLIENT.getToken(code, (err, token) => {

            if (err) {
                _.logger.error(`Error while trying to retrieve the YouTube API's access token, because: ${err}`);
                return resolve(false);
            }

            // generate the directory for token files, if it does not yet exist
            let token_dir = _.path.dirname(TOKEN_PATH);
            if (!_.fs.existsSync(token_dir)) {
                _.fs.mkdirSync(token_dir, {
                    recursive : true
                })
            }
            
            // store token as a file
            _.fs.writeFileSync(TOKEN_PATH, JSON.stringify(token));
            
            return resolve(true);
        });
    });
}



/*
 * ================
 * PUBLIC FUNCTIONS
 * ================
 */

const __public = {
    
    /*
     * VALIDATION
     */
    
    /**
     * checks if a value is a valid privacy status value
     *
     * @function
     * @alias module:uploader
     * @category public
     *
     * @param {string} value - information about the authors of the lecture
     * @returns {boolean} true, if the value is valid
     */
    isValidPrivacyStatus : value => {
        return ['public','unlisted','private'].includes(value);
    },
    
    /**
     * checks if a YouTube playlist is viewable by the channel belonging to the credentials
     *  will be true for all public playlists, as well as private/unlisted playlists of the authenticated channel
     *
     * @async
     * @function
     * @alias module:uploader
     * @category public
     *
     * @param {string} credential_file - absolute path to the YouTube credentials file
     * @param {string} playlist_id - id of the YouTube playlist
     * @returns {Promise.<boolean>} true, if the playlist exists
     */
    playlistExists : async(credential_file, playlist_id) => {
        
        if (!_.basic.isFile(credential_file, '.json')) {
            _.logger.error(`Expected path to an existing JSON credentials file, but got ${_.type.of(credential_file)} "${credential_file}"`);
            return;
        }
        
        if (!_.type.isString(playlist_id) || playlist_id === '') {
            _.logger.error(`Expected a playlist id as a string, but got ${_.type.of(playlist_id)} "${playlist_id}"`);
            return;
        }
        
        // ------------
        
        // initialize a client for the API
        const success = await initClient(credential_file);
        if (!success) {
            _.logger.error(`Failed initializing an OAuth2 client`);
            return;
        }
            
        // authentificate API client for YouTube
        const youtube = _.googleapis.google.youtube({
            version : 'v3',
            auth    : OAUTH2_CLIENT
        });

        // generate API request options
        const api_options = {
            part : 'snippet',
            playlistId : playlist_id
        };
        
        return await new Promise(async(resolve) => {
            
            youtube.playlistItems.list(api_options, (err, response) => {
                
                // return false, if the playlist could not be found
                if (err) return resolve(false);
                
                return resolve(true);
            });
        });
    },
    
    /**
     * checks if a YouTube playlist is owned by the channel belonging to the credentials
     *
     * @async
     * @function
     * @alias module:uploader
     * @category public
     *
     * @param {string} credential_file - absolute path to the YouTube credentials file
     * @param {string} playlist_id - id of the YouTube playlist
     * @returns {Promise.<boolean>} true, if the playlist exists
     */
    isUsersPlaylist : async(credential_file, playlist_id) => {
        
        if (!_.basic.isFile(credential_file, '.json')) {
            _.logger.error(`Expected path to an existing JSON credentials file, but got ${_.type.of(credential_file)} "${credential_file}"`);
            return;
        }
        
        if (!_.type.isString(playlist_id)) {
            _.logger.error(`Expected a playlist id as a string, but got ${_.type.of(playlist_id)} "${playlist_id}"`);
            return;
        }
        
        // ------------
            
        // initialize a client for the API
        const success = await initClient(credential_file);
        if (!success) {
            _.logger.error(`Failed initializing an OAuth2 client`);
            return;
        }
            
        // authentificate API client for YouTube
        const youtube = _.googleapis.google.youtube({
            version : 'v3',
            auth    : OAUTH2_CLIENT
        });

        // generate API request options
        const api_options = {
            part : 'snippet',
            // only get playlists owned by the authenticated account
            mine : true,
            maxResults : 50
        };
        
        return await new Promise(async(resolve) => {
            
            youtube.playlists.list(api_options, (err, response) => {
                
                // return false, if the API could not be accessed
                if (err) {
                    _.logger.error(`Failed accessing the Googleapis, because: ${err}`);
                    return resolve(false);
                }
                
                // check if the authenticated user has a playlist with the given ID
                const playlist_found = response.data.items.some(playlist => {
                    return playlist.id === playlist_id;
                });
                
                return resolve(playlist_found);
            });
        });
    },
    
    /**
     * checks if a YouTube video exists
     *  will be true for all public videos, as well as private/unlisted playlists of the authenticated channel
     *
     * @async
     * @function
     * @alias module:uploader
     * @category public
     *
     * @param {string} credential_file - absolute path to the YouTube credentials file
     * @param {string} video_id - id of the YouTube video
     * @returns {Promise.<boolean>} true, if the video exists
     */
    videoExists : async(credential_file, video_id) => {
        
        if (!_.basic.isFile(credential_file, '.json')) {
            _.logger.error(`Expected path to an existing JSON credentials file, but got ${_.type.of(credential_file)} "${credential_file}"`);
            return;
        }
        
        if (!_.type.isString(video_id) || video_id === '') {
            _.logger.error(`Expected a video id as a string, but got ${_.type.of(video_id)} "${video_id}"`);
            return;
        }
        
        // ------------
        
        // initialize a client for the API
        const success = await initClient(credential_file);
        if (!success) {
            _.logger.error(`Failed initializing an OAuth2 client`);
            return;
        }
            
        // authentificate API client for YouTube
        const youtube = _.googleapis.google.youtube({
            version : 'v3',
            auth    : OAUTH2_CLIENT
        });

        // generate API request options
        const api_options = {
            part : 'status',
            id : video_id
        };
        
        return await new Promise(async(resolve) => {
            
            youtube.videos.list(api_options, (err, response) => {
                
                // return false, if the API could not be accessed
                if (err) {
                    _.logger.error(`Failed accessing the Googleapis, because: ${err}`);
                    return resolve(false);
                }
                
                return resolve(response.data.items.length === 1);
            });
        });
    },
    
    
    
    /*
     * GENERATION
     */
    
    /**
     * generates a YouTube description with timestamps for chapters
     *
     * @function
     * @alias module:uploader
     * @category public
     *
     * @param {Object} options
     * @param {string} options.description - main passage that describes the video
     * @param {string} [options.copyright] - copyright information about the video
     * @param {string} [options.authors] - information about the authors of the lecture
     * @param {Array.<Object>} [options.chapters] - definitions at which timestamps chapters begin
     * @returns {string} YouTube video description
     */
    generateDescription : options => {
        
        // required parameters
        
        if (!_.type.isObject(options)) {
            _.logger.error(`Expected options as an object, but got ${_.type.of(options)} "${options}"`);
            return;
        }
        
        if (!_.type.isString(options.description) || options.description === '') {
            _.logger.error(`Expected options.description as a string, but got ${_.type.of(options.description)} "${options.description}"`);
            return;
        }
        
        // optional parameters
        
        if (
            options.copyright !== undefined && 
            (!_.type.isString(options.copyright) || options.copyright === '')
        ) {
            _.logger.error(`Expected options.copyright to be a string, but got ${_.type.of(options.copyright)} "${options.copyright}"`);
            return;
        }
        
        if (
            options.authors !== undefined && 
            (!_.type.isString(options.authors) || options.authors === '')
        ) {
            _.logger.error(`Expected options.authors to be a string, but got ${_.type.of(options.authors)} "${options.authors}"`);
            return;
        }
        
        if (
            options.chapters !== undefined && 
            (!_.type.isArray(options.chapters) || !options.chapters.every(_.type.isObject))
        ) {
            _.logger.error(`Expected options.chapters to be an array of only objects, but got ${_.type.of(options.chapters)} "${options.chapters}"`);
            return;
        }
        
        // ------------
        
        // generate description string
        let description = options.description + EOL + EOL + 
                          (options.copyright ? options.copyright + EOL : '') + 
                          (options.authors ? options.authors + EOL : '');
        
        if (options.chapters) {
            
            options.chapters.forEach(chapter => {
                description += EOL + _.timestamp.ffmpeg2youtube(chapter.start_time) + ' ' + chapter.title;
            });
        }
        
        return description;
    },
    
    
    
    /*
     * YOUTUBE API
     */
    
    /**
     * uploads a video to YouTube
     *
     * @async
     * @function
     * @alias module:uploader
     * @category public
     *
     * @param {Object} options
     * @param {string} options.credential_file - absolute path to the YouTube credentials file
     * @param {string} options.input_path - absolute path to a video file
     * @param {string} options.title - title of the YouTube video
     * @param {string} options.description - description of the YouTube video
     * @param {public|private|unlisted} options.privacy_status - privacy status of the YouTube video
     * @returns {Promise.<string|undefined>} returns YouTube id to where the video was uploaded on success
     */
    uploadToYoutube : async(options) => {
        
        // required parameters
        
        if (!_.type.isObject(options)) {
            _.logger.error(`Expected options as an object, but got ${_.type.of(options)} "${options}"`);
            return;
        }
        
        if (!_.basic.isFile(options.credential_file, '.json')) {
            _.logger.error(`Expected options.credential_file as a path to an existing JSON credentials file, but got ${_.type.of(options.credential_file)} "${options.credential_file}"`);
            return;
        }
        
        if (!_.basic.isFile(options.input_path)) {
            _.logger.error(`Expected options.input_path as a path to an existing file, but got ${_.type.of(options.input_path)} "${options.input_path}"`);
            return;
        }
        
        // YouTube's upload limit is 128 GB: https://developers.google.com/youtube/v3/docs/videos/insert
        // set warning level here at roughly 120 GB as a safety measure
        if (_.basic.getFileSize(options.input_path) > 120000000000) {
            _.logger.error(`File "${options.input_path}" is too big with a file size >120 GB`);
            return;
        }
        
        if (!_.type.isString(options.title) || options.title === '') {
            _.logger.error(`Expected options.title as a string, but got ${_.type.of(options.title)} "${options.title}"`);
            return;
        }
        
        if (!_.type.isString(options.description) || options.description === '') {
            _.logger.error(`Expected options.description as a string, but got ${_.type.of(options.description)} "${options.description}"`);
            return;
        }
        
        if (!_.type.isString(options.privacy_status)) {
            _.logger.error(`Expected options.privacy_status as a string, but got ${_.type.of(options.privacy_status)} "${options.privacy_status}"`);
            return;
        }
        
        if (!['public','private','unlisted'].includes(options.privacy_status)) {
            _.logger.error(`Got privacy status "${options.privacy_status}", but it must be one of the following: public | private | unlisted`);
            return;
        }
        
        // ------------
            
        // initialize a client for the API
        const success = await initClient(options.credential_file);
        if (!success) {
            _.logger.error(`Failed initializing an OAuth2 client`);
            return;
        }
            
        // authentificate API client for YouTube
        const youtube = _.googleapis.google.youtube({
            version : 'v3',
            auth    : OAUTH2_CLIENT
        });

        // generate API request options
        const api_options = {
            resource : {
                snippet : {
                    title       : options.title,
                    description : options.description,
                    tags        : options.tags
                },
                status : {
                    privacyStatus : options.privacy_status
                }
            },
            part : 'snippet,status',
            media : {
                body : _.fs.createReadStream(options.input_path)
            }
        };
        
        return new Promise(async(resolve) => {

            // upload the video
            youtube.videos.insert(api_options, (err, response) => {
                
                // check if there was an error uploading the video
                if (err) {
                    _.logger.error(`Failed uploading the video "${options.title}", because: ${err}`);
                    return resolve();
                }
                
                // resolve with the id of the YouTube video
                return resolve(response.data.id);
            });
        });
    },
    
    /**
     * checks if a YouTube playlist on the user's channel exists for the given ID
     *
     * @async
     * @function
     * @alias module:uploader
     * @category public
     *
     * @param {Object} options - absolute path to the YouTube credentials file
     * @param {string} options.credential_file - absolute path to the YouTube credentials file
     * @param {string} options.video_id - id of the YouTube video to be inserted
     * @param {string} options.playlist_id - id of the YouTube playlist
     * @param {integer} [options.position=0] - position greater than 0 at which to insert the video into the playlist
     * @returns {Promise.<boolean>} true on success
     */
    insertIntoPlaylist : async(options) => {
        
        if (!_.basic.isFile(options.credential_file, '.json')) {
            _.logger.error(`Expected options.credential_file as a path to an existing JSON credentials file, but got ${_.type.of(options.credential_file)} "${options.credential_file}"`);
            return;
        }
        
        if (!_.type.isString(options.video_id) || options.video_id === '') {
            _.logger.error(`Expected options.video_id as a string, but got ${_.type.of(options.video_id)} "${options.video_id}"`);
            return;
        }
        
        if (!(await __public.videoExists(options.credential_file, options.video_id))) {
            _.logger.error(`Video "${options.video_id}" does not exist`);
            return;
        }
        
        if (!_.type.isString(options.playlist_id) || options.playlist_id === '') {
            _.logger.error(`Expected options.playlist_id as a string, but got ${_.type.of(options.playlist_id)} "${options.playlist_id}"`);
            return;
        }
        
        if (!(await __public.isUsersPlaylist(options.credential_file, options.playlist_id))) {
            _.logger.error(`Playlist "${options.playlist_id}" does not exist`);
            return;
        }
        
        // set default position if needed
        if (!_.type.isInteger(options.position) || options.position < 0) {
            options.position = 0;
        }
        
        // ------------
        
        // initialize a client for the API
        const success = await initClient(options.credential_file);
        if (!success) {
            _.logger.error(`Failed initializing an OAuth2 client`);
            return;
        }
            
        // authentificate API client for YouTube
        const youtube = _.googleapis.google.youtube({
            version : 'v3',
            auth    : OAUTH2_CLIENT
        });

        // generate API request options
        const api_options = {
            part : 'id,snippet',
            resource : {
                snippet : {
                    playlistId : options.playlist_id,
                    position : options.position,
                    resourceId : {
                        kind : 'youtube#video',
                        videoId : options.video_id
                    }
                }
            }
        };
        
        return await new Promise(async(resolve) => {
            
            youtube.playlistItems.insert(api_options, (err, response) => {
                
                // return false, if the API could not be accessed
                if (err) {
                    _.logger.error(`Failed accessing the Googleapis, because: ${err}`);
                    return resolve(false);
                }
                
                return resolve(true);
            });
        });
    }
};

module.exports = __public;